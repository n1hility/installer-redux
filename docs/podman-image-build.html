<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>podman-build(1)</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h2 id="name">NAME</h2>
<p>podman-build - Build a container image using a Containerfile</p>
<h2 id="synopsis">SYNOPSIS</h2>
<p><strong>podman build</strong> [<em>options</em>]
[<em>context</em>]</p>
<p><strong>podman image build</strong> [<em>options</em>]
[<em>context</em>]</p>
<h2 id="description">DESCRIPTION</h2>
<p><strong>podman build</strong> Builds an image using instructions from
one or more Containerfiles or Dockerfiles and a specified build context
directory. A Containerfile uses the same syntax as a Dockerfile
internally. For this document, a file referred to as a Containerfile can
be a file named either 'Containerfile' or 'Dockerfile'.</p>
<p>The build context directory can be specified as the http(s) URL of an
archive, git repository or Containerfile.</p>
<p>If no context directory is specified, then Podman will assume the
current working directory as the build context, which should contain the
Containerfile.</p>
<p>Containerfiles ending with a ".in" suffix will be preprocessed via
CPP(1). This can be useful to decompose Containerfiles into several
reusable parts that can be used via CPP's <strong>#include</strong>
directive. Notice, a Containerfile.in file can still be used by other
tools when manually preprocessing them via <code>cpp -E</code>.</p>
<p>When the URL is an archive, the contents of the URL is downloaded to
a temporary location and extracted before execution.</p>
<p>When the URL is a Containerfile, the Containerfile is downloaded to a
temporary location.</p>
<p>When a Git repository is set as the URL, the repository is cloned
locally and then set as the context.</p>
<p>NOTE: <code>podman build</code> uses code sourced from the
<code>Buildah</code> project to build container images. This
<code>Buildah</code> code creates <code>Buildah</code> containers for
the <code>RUN</code> options in container storage. In certain
situations, when the <code>podman build</code> crashes or users kill the
<code>podman build</code> process, these external containers can be left
in container storage. Use the <code>podman ps --all --storage</code>
command to see these containers. External containers can be removed with
the <code>podman rm --storage</code> command.</p>
<p><code>podman buildx build</code> command is an alias of
<code>podman build</code>. Not all <code>buildx build</code> features
are available in Podman. The <code>buildx build</code> option is
provided for scripting compatibility.</p>
<h2 id="options">OPTIONS</h2>
<h4
id="add-hosthostip"><strong>--add-host</strong>=<em>host:ip</em></h4>
<p>Add a custom host-to-IP mapping (host:ip)</p>
<p>Add a line to /etc/hosts. The format is hostname:ip. The
<strong>--add-host</strong> option can be set multiple times. Conflicts
with the <strong>--no-hosts</strong> option.</p>
<h4 id="all-platforms"><strong>--all-platforms</strong></h4>
<p>Instead of building for a set of platforms specified using the
<strong>--platform</strong> option, inspect the build's base images, and
build for all of the platforms for which they are all available. Stages
that use <em>scratch</em> as a starting point can not be inspected, so
at least one non-<em>scratch</em> stage must be present for detection to
work usefully.</p>
<h4
id="annotationannotation"><strong>--annotation</strong>=<em>annotation</em></h4>
<p>Add an image <em>annotation</em> (e.g. annotation=<em>value</em>) to
the image metadata. Can be used multiple times.</p>
<p>Note: this information is not present in Docker image formats, so it
is discarded when writing images in Docker formats.</p>
<h4 id="archarch"><strong>--arch</strong>=<em>arch</em></h4>
<p>Set the architecture of the image to be built, and that of the base
image to be pulled, if the build uses one, to the provided value instead
of using the architecture of the build host. (Examples: arm, arm64, 386,
amd64, ppc64le, s390x)</p>
<h4 id="authfilepath"><strong>--authfile</strong>=<em>path</em></h4>
<p>Path of the authentication file. Default is
${XDG_RUNTIME_DIR}/containers/auth.json, which is set using
<code>podman login</code>. If the authorization state is not found
there, $HOME/.docker/config.json is checked, which is set using
<code>docker login</code>.</p>
<p>Note: You can also override the default path of the authentication
file by setting the REGISTRY_AUTH_FILE environment variable.
<code>export REGISTRY_AUTH_FILE=path</code></p>
<h4
id="build-argargvalue"><strong>--build-arg</strong>=<em>arg=value</em></h4>
<p>Specifies a build argument and its value, which will be interpolated
in instructions read from the Containerfiles in the same way that
environment variables are, but which will not be added to environment
variable list in the resulting image's configuration.</p>
<h4
id="build-contextnamevalue"><strong>--build-context</strong>=<em>name=value</em></h4>
<p>Specify an additional build context using its short name and its
location. Additional build contexts can be referenced in the same manner
as we access different stages in COPY instruction.</p>
<p>Valid values could be:</p>
<ul>
<li>Local directory &#x2013; e.g. --build-context
project2=../path/to/project2/src (This option is not available with the
remote Podman client. On Podman machine setup (i.e macOS and Winows)
path must exists on the machine VM)</li>
<li>HTTP URL to a tarball &#x2013; e.g. --build-context
src=https://example.org/releases/src.tar</li>
<li>Container image &#x2013; specified with a container-image:// prefix, e.g.
--build-context alpine=container-image://alpine:3.15, (also accepts
docker://, docker-image://)</li>
</ul>
<p>On the Containerfile side, you can reference the build context on all
commands that accept the &#x201C;from&#x201D; parameter. Here&#x2019;s how that might
look:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> [name]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> <span class="op">--from=[name]</span> ...</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="op">--mount=from=[name]</span> <span class="ex">&#x2026;</span></span></code></pre></div>
<p>The value of <a href="#name">name</a> is matched with the following
priority order:</p>
<ul>
<li>Named build context defined with --build-context <a
href="#name">name</a>=..</li>
<li>Stage defined with AS <a href="#name">name</a> inside
Containerfile</li>
<li>Image <a href="#name">name</a>, either local or in a remote
registry</li>
</ul>
<h4 id="cache-from"><strong>--cache-from</strong></h4>
<p>Repository to utilize as a potential cache source. When specified,
Buildah will try to look for cache images in the specified repository
and will attempt to pull cache images instead of actually executing the
build steps locally. Buildah will only attempt to pull previously cached
images if they are considered as valid cache hits.</p>
<p>Use the <code>--cache-to</code> option to populate a remote
repository with cache content.</p>
<p>Example</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># populate a cache and also consult it</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ex">buildah</span> build <span class="at">-t</span> test <span class="at">--layers</span> <span class="at">--cache-to</span> registry/myrepo/cache <span class="at">--cache-from</span> registry/myrepo/cache .</span></code></pre></div>
<p>Note: <code>--cache-from</code> option is ignored unless
<code>--layers</code> is specified.</p>
<h4 id="cache-to"><strong>--cache-to</strong></h4>
<p>Set this flag to specify a remote repository that will be used to
store cache images. Buildah will attempt to push newly built cache image
to the remote repository.</p>
<p>Note: Use the <code>--cache-from</code> option in order to use cache
content in a remote repository.</p>
<p>Example</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># populate a cache and also consult it</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ex">buildah</span> build <span class="at">-t</span> test <span class="at">--layers</span> <span class="at">--cache-to</span> registry/myrepo/cache <span class="at">--cache-from</span> registry/myrepo/cache .</span></code></pre></div>
<p>Note: <code>--cache-to</code> option is ignored unless
<code>--layers</code> is specified.</p>
<h4 id="cache-ttl"><strong>--cache-ttl</strong></h4>
<p>Limit the use of cached images to only consider images with created
timestamps less than <em>duration</em> ago. For example if
<code>--cache-ttl=1h</code> is specified, Buildah will only consider
intermediate cache images which are created under the duration of one
hour, and intermediate cache images outside this duration will be
ignored.</p>
<h4 id="cap-addcap_xxx"><strong>--cap-add</strong>=<em>CAP_xxx</em></h4>
<p>When executing RUN instructions, run the command specified in the
instruction with the specified capability added to its capability set.
Certain capabilities are granted by default; this option can be used to
add more.</p>
<h4
id="cap-dropcap_xxx"><strong>--cap-drop</strong>=<em>CAP_xxx</em></h4>
<p>When executing RUN instructions, run the command specified in the
instruction with the specified capability removed from its capability
set. The CAP_AUDIT_WRITE, CAP_CHOWN, CAP_DAC_OVERRIDE, CAP_FOWNER,
CAP_FSETID, CAP_KILL, CAP_MKNOD, CAP_NET_BIND_SERVICE, CAP_SETFCAP,
CAP_SETGID, CAP_SETPCAP, CAP_SETUID, and CAP_SYS_CHROOT capabilities are
granted by default; this option can be used to remove them.</p>
<p>If a capability is specified to both the <strong>--cap-add</strong>
and <strong>--cap-drop</strong> options, it will be dropped, regardless
of the order in which the options were given.</p>
<h4 id="cert-dirpath"><strong>--cert-dir</strong>=<em>path</em></h4>
<p>Use certificates at <em>path</em> (*.crt, *.cert, *.key) to connect
to the registry. (Default: /etc/containers/certs.d) Please refer to
containers-certs.d(5) for details. (This option is not available with
the remote Podman client, including Mac and Windows (excluding WSL2)
machines)</p>
<h4
id="cgroup-parentpath"><strong>--cgroup-parent</strong>=<em>path</em></h4>
<p>Path to cgroups under which the cgroup for the container will be
created. If the path is not absolute, the path is considered to be
relative to the cgroups path of the init process. Cgroups will be
created if they do not already exist.</p>
<h4 id="cgroupnshow"><strong>--cgroupns</strong>=<em>how</em></h4>
<p>Sets the configuration for cgroup namespaces when handling
<code>RUN</code> instructions. The configured value can be "" (the empty
string) or "private" to indicate that a new cgroup namespace should be
created, or it can be "host" to indicate that the cgroup namespace in
which <code>buildah</code> itself is being run should be reused.</p>
<h4 id="compress"><strong>--compress</strong></h4>
<p>This option is added to be aligned with other containers CLIs. Podman
doesn't communicate with a daemon or a remote server. Thus, compressing
the data before sending it is irrelevant to Podman. (This option is not
available with the remote Podman client, including Mac and Windows
(excluding WSL2) machines)</p>
<h4 id="cpp-flagflags"><strong>--cpp-flag</strong>=<em>flags</em></h4>
<p>Set additional flags to pass to the C Preprocessor cpp(1).
Containerfiles ending with a ".in" suffix will be preprocessed via
cpp(1). This option can be used to pass additional flags to cpp.Note:
You can also set default CPPFLAGS by setting the BUILDAH_CPPFLAGS
environment variable (e.g., export BUILDAH_CPPFLAGS="-DDEBUG").</p>
<h4
id="cpu-periodlimit"><strong>--cpu-period</strong>=<em>limit</em></h4>
<p>Set the CPU period for the Completely Fair Scheduler (CFS), which is
a duration in microseconds. Once the container's CPU quota is used up,
it will not be scheduled to run until the current period ends. Defaults
to 100000 microseconds.</p>
<p>On some systems, changing the CPU limits may not be allowed for
non-root users. For more details, see
https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-cpu-limits-fails-with-a-permissions-error</p>
<h4 id="cpu-quotalimit"><strong>--cpu-quota</strong>=<em>limit</em></h4>
<p>Limit the CPU Completely Fair Scheduler (CFS) quota.</p>
<p>Limit the container's CPU usage. By default, containers run with the
full CPU resource. The limit is a number in microseconds. If a number is
provided, the container will be allowed to use that much CPU time until
the CPU period ends (controllable via
<strong>--cpu-period</strong>).</p>
<p>On some systems, changing the CPU limits may not be allowed for
non-root users. For more details, see
https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-cpu-limits-fails-with-a-permissions-error</p>
<h4 id="cpu-shares--cshares"><strong>--cpu-shares</strong>,
<strong>-c</strong>=<em>shares</em></h4>
<p>CPU shares (relative weight).</p>
<p>By default, all containers get the same proportion of CPU cycles.
This proportion can be modified by changing the container's CPU share
weighting relative to the combined weight of all the running containers.
Default weight is <strong>1024</strong>.</p>
<p>The proportion will only apply when CPU-intensive processes are
running. When tasks in one container are idle, other containers can use
the left-over CPU time. The actual amount of CPU time will vary
depending on the number of containers running on the system.</p>
<p>For example, consider three containers, one has a cpu-share of 1024
and two others have a cpu-share setting of 512. When processes in all
three containers attempt to use 100% of CPU, the first container would
receive 50% of the total CPU time. If a fourth container is added with a
cpu-share of 1024, the first container only gets 33% of the CPU. The
remaining containers receive 16.5%, 16.5% and 33% of the CPU.</p>
<p>On a multi-core system, the shares of CPU time are distributed over
all CPU cores. Even if a container is limited to less than 100% of CPU
time, it can use 100% of each individual CPU core.</p>
<p>For example, consider a system with more than three cores. If the
container <em>C0</em> is started with <strong>--cpu-shares=512</strong>
running one process, and another container <em>C1</em> with
<strong>--cpu-shares=1024</strong> running two processes, this can
result in the following division of CPU shares:</p>
<table>
<thead>
<tr class="header">
<th>PID</th>
<th>container</th>
<th>CPU</th>
<th>CPU share</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>100</td>
<td>C0</td>
<td>0</td>
<td>100% of CPU0</td>
</tr>
<tr class="even">
<td>101</td>
<td>C1</td>
<td>1</td>
<td>100% of CPU1</td>
</tr>
<tr class="odd">
<td>102</td>
<td>C1</td>
<td>2</td>
<td>100% of CPU2</td>
</tr>
</tbody>
</table>
<h4
id="cpuset-cpusnumber"><strong>--cpuset-cpus</strong>=<em>number</em></h4>
<p>CPUs in which to allow execution. Can be specified as a
comma-separated list (e.g. <strong>0,1</strong>), as a range (e.g.
<strong>0-3</strong>), or any combination thereof (e.g.
<strong>0-3,7,11-15</strong>).</p>
<h4
id="cpuset-memsnodes"><strong>--cpuset-mems</strong>=<em>nodes</em></h4>
<p>Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only
effective on NUMA systems.</p>
<p>If there are four memory nodes on the system (0-3), use
<strong>--cpuset-mems=0,1</strong> then processes in the container will
only use memory from the first two memory nodes.</p>
<h4 id="credscreds"><strong>--creds</strong>=<em>creds</em></h4>
<p>The [username[:password]] to use to authenticate with the registry if
required. If one or both values are not supplied, a command line prompt
will appear and the value can be entered. The password is entered
without echo.</p>
<h4
id="decryption-keykeypassphrase"><strong>--decryption-key</strong>=<em>key[:passphrase]</em></h4>
<p>The [key[:passphrase]] to be used for decryption of images. Key can
point to keys and/or certificates. Decryption will be tried with all
keys. If the key is protected by a passphrase, it is required to be
passed in the argument and omitted otherwise.</p>
<h4
id="devicehost-devicecontainer-devicepermissions"><strong>--device</strong>=<em>host-device[:container-device][:permissions]</em></h4>
<p>Add a host device to the container. Optional <em>permissions</em>
parameter can be used to specify device permissions, it is combination
of <strong>r</strong> for read, <strong>w</strong> for write, and
<strong>m</strong> for <strong>mknod</strong>(2).</p>
<p>Example: <strong>--device=/dev/sdc:/dev/xvdc:rwm</strong>.</p>
<p>Note: if <em>host-device</em> is a symbolic link then it will be
resolved first. The container will only store the major and minor
numbers of the host device.</p>
<p>Note: if the user only has access rights via a group, accessing the
device from inside a rootless container will fail. The <strong><a
href="https://github.com/containers/crun/tree/main/crun.html">crun(1)</a></strong>
runtime offers a workaround for this by adding the option
<strong>--annotation run.oci.keep_original_groups=1</strong>.</p>
<h4 id="disable-compression--d"><strong>--disable-compression</strong>,
<strong>-D</strong></h4>
<p>Don't compress filesystem layers when building the image unless it is
required by the location where the image is being written. This is the
default setting, because image layers are compressed automatically when
they are pushed to registries, and images being written to local storage
would only need to be decompressed again to be stored. Compression can
be forced in all cases by specifying
<strong>--disable-compression=false</strong>.</p>
<h4
id="disable-content-trust"><strong>--disable-content-trust</strong></h4>
<p>This is a Docker specific option to disable image verification to a
container registry and is not supported by Podman. This option is a NOOP
and provided solely for scripting compatibility. (This option is not
available with the remote Podman client, including Mac and Windows
(excluding WSL2) machines)</p>
<h4 id="dnsdns"><strong>--dns</strong>=<em>dns</em></h4>
<p>Set custom DNS servers to be used during the build.</p>
<p>This option can be used to override the DNS configuration passed to
the container. Typically this is necessary when the host DNS
configuration is invalid for the container (e.g., 127.0.0.1). When this
is the case the <code>--dns</code> option is necessary for every
run.</p>
<p>The special value <strong>none</strong> can be specified to disable
creation of /etc/resolv.conf in the container by Podman. The
/etc/resolv.conf file in the image will be used without changes.</p>
<h4
id="dns-optionoption"><strong>--dns-option</strong>=<em>option</em></h4>
<p>Set custom DNS options to be used during the build.</p>
<h4
id="dns-searchdomain"><strong>--dns-search</strong>=<em>domain</em></h4>
<p>Set custom DNS search domains to be used during the build.</p>
<h4 id="envenvvalue"><strong>--env</strong>=<em>env[=value]</em></h4>
<p>Add a value (e.g. env=<em>value</em>) to the built image. Can be used
multiple times. If neither <code>=</code> nor a <code>*value*</code> are
specified, but <em>env</em> is set in the current environment, the value
from the current environment will be added to the image. To remove an
environment variable from the built image, use the
<code>--unsetenv</code> option.</p>
<h4 id="file--fcontainerfile"><strong>--file</strong>,
<strong>-f</strong>=<em>Containerfile</em></h4>
<p>Specifies a Containerfile which contains instructions for building
the image, either a local file or an <strong>http</strong> or
<strong>https</strong> URL. If more than one Containerfile is specified,
<em>FROM</em> instructions will only be accepted from the first
specified file.</p>
<p>If a build context is not specified, and at least one Containerfile
is a local file, the directory in which it resides will be used as the
build context.</p>
<p>If you specify <code>-f -</code>, the Containerfile contents will be
read from stdin.</p>
<h4 id="force-rm"><strong>--force-rm</strong></h4>
<p>Always remove intermediate containers after a build, even if the
build fails (default true).</p>
<h4 id="format"><strong>--format</strong></h4>
<p>Control the format for the built image's manifest and configuration
data. Recognized formats include <em>oci</em> (OCI image-spec v1.0, the
default) and <em>docker</em> (version 2, using schema format 2 for the
manifest).</p>
<p>Note: You can also override the default format by setting the
BUILDAH_FORMAT environment variable.
<code>export BUILDAH_FORMAT=docker</code></p>
<h4 id="from"><strong>--from</strong></h4>
<p>Overrides the first <code>FROM</code> instruction within the
Containerfile. If there are multiple FROM instructions in a
Containerfile, only the first is changed.</p>
<h4 id="help--h"><strong>--help</strong>, <strong>-h</strong></h4>
<p>Print usage statement</p>
<h4 id="http-proxy"><strong>--http-proxy</strong></h4>
<p>Pass through HTTP Proxy environment variables.</p>
<h4 id="identity-label"><strong>--identity-label</strong></h4>
<p>Adds default identity label <code>io.buildah.version</code> if set.
(default true).</p>
<h4 id="ignorefile"><strong>--ignorefile</strong></h4>
<p>Path to an alternative .containerignore file.</p>
<h4
id="iidfileimageidfile"><strong>--iidfile</strong>=<em>ImageIDfile</em></h4>
<p>Write the built image's ID to the file. When <code>--platform</code>
is specified more than once, attempting to use this option will trigger
an error.</p>
<h4 id="ipchow"><strong>--ipc</strong>=<em>how</em></h4>
<p>Sets the configuration for IPC namespaces when handling
<code>RUN</code> instructions. The configured value can be "" (the empty
string) or "container" to indicate that a new IPC namespace should be
created, or it can be "host" to indicate that the IPC namespace in which
<code>podman</code> itself is being run should be reused, or it can be
the path to an IPC namespace which is already in use by another
process.</p>
<h4 id="isolationtype"><strong>--isolation</strong>=<em>type</em></h4>
<p>Controls what type of isolation is used for running processes as part
of <code>RUN</code> instructions. Recognized types include <em>oci</em>
(OCI-compatible runtime, the default), <em>rootless</em> (OCI-compatible
runtime invoked using a modified configuration and its --rootless option
enabled, with <em>--no-new-keyring --no-pivot</em> added to its
<em>create</em> invocation, with network and UTS namespaces disabled,
and IPC, PID, and user namespaces enabled; the default for unprivileged
users), and <em>chroot</em> (an internal wrapper that leans more toward
chroot(1) than container technology).</p>
<p>Note: You can also override the default isolation type by setting the
BUILDAH_ISOLATION environment variable.
<code>export BUILDAH_ISOLATION=oci</code></p>
<h4 id="jobsnumber"><strong>--jobs</strong>=<em>number</em></h4>
<p>Run up to N concurrent stages in parallel. If the number of jobs is
greater than 1, stdin will be read from /dev/null. If 0 is specified,
then there is no limit in the number of jobs that run in parallel.</p>
<h4 id="labellabel"><strong>--label</strong>=<em>label</em></h4>
<p>Add an image <em>label</em> (e.g. label=<em>value</em>) to the image
metadata. Can be used multiple times.</p>
<p>Users can set a special LABEL
<strong>io.containers.capabilities=CAP1,CAP2,CAP3</strong> in a
Containerfile that specifies the list of Linux capabilities required for
the container to run properly. This label specified in a container image
tells Podman to run the container with just these capabilities. Podman
launches the container with just the specified capabilities, as long as
this list of capabilities is a subset of the default list.</p>
<p>If the specified capabilities are not in the default set, Podman will
print an error message and will run the container with the default
capabilities.</p>
<h4 id="layers"><strong>--layers</strong></h4>
<p>Cache intermediate images during the build process (Default is
<code>true</code>).</p>
<p>Note: You can also override the default value of layers by setting
the BUILDAH_LAYERS environment variable.
<code>export BUILDAH_LAYERS=true</code></p>
<h4
id="logfilefilename"><strong>--logfile</strong>=<em>filename</em></h4>
<p>Log output which would be sent to standard output and standard error
to the specified file instead of to standard output and standard error.
This option is not supported on the remote client, including Mac and
Windows (excluding WSL2) machines.</p>
<h4
id="logsplitbool-value"><strong>--logsplit</strong>=<em>bool-value</em></h4>
<p>If <code>--logfile</code> and <code>--platform</code> are specified,
the <code>--logsplit</code> option allows end-users to split the log
file for each platform into different files in the following format:
<code>${logfile}_${platform-os}_${platform-arch}</code>. This option is
not supported on the remote client, including Mac and Windows (excluding
WSL2) machines.</p>
<h4
id="manifestmanifest"><strong>--manifest</strong>=<em>manifest</em></h4>
<p>Name of the manifest list to which the image will be added. Creates
the manifest list if it does not exist. This option is useful for
building multi architecture images.</p>
<h4 id="memory--mlimit"><strong>--memory</strong>,
<strong>-m</strong>=<em>LIMIT</em></h4>
<p>Memory limit (format: <code>&lt;number&gt;[&lt;unit&gt;]</code>,
where unit = b (bytes), k (kibibytes), m (mebibytes), or g
(gibibytes))</p>
<p>Allows you to constrain the memory available to a container. If the
host supports swap memory, then the <strong>-m</strong> memory setting
can be larger than physical RAM. If a limit of 0 is specified (not using
<strong>-m</strong>), the container's memory is not limited. The actual
limit may be rounded up to a multiple of the operating system's page
size (the value would be very large, that's millions of trillions).</p>
<h4
id="memory-swaplimit"><strong>--memory-swap</strong>=<em>LIMIT</em></h4>
<p>A limit value equal to memory plus swap. Must be used with the
<strong>-m</strong> (<strong>--memory</strong>) option. The swap
<code>LIMIT</code> should always be larger than <strong>-m</strong>
(<strong>--memory</strong>) value. By default, the swap
<code>LIMIT</code> will be set to double the value of --memory.</p>
<p>The format of <code>LIMIT</code> is
<code>&lt;number&gt;[&lt;unit&gt;]</code>. Unit can be <code>b</code>
(bytes), <code>k</code> (kibibytes), <code>m</code> (mebibytes), or
<code>g</code> (gibibytes). If you don't specify a unit, <code>b</code>
is used. Set LIMIT to <code>-1</code> to enable unlimited swap.</p>
<h4 id="networkmode---net"><strong>--network</strong>=<em>mode</em>,
<strong>--net</strong></h4>
<p>Sets the configuration for network namespaces when handling
<code>RUN</code> instructions.</p>
<p>Valid <em>mode</em> values are:</p>
<ul>
<li><strong>none</strong>: no networking.</li>
<li><strong>host</strong>: use the Podman host network stack. Note: the
host mode gives the container full access to local system services such
as D-bus and is therefore considered insecure.</li>
<li><strong>ns:</strong>_path_: path to a network namespace to
join.</li>
<li><strong>private</strong>: create a new namespace for the container
(default)</li>
<li><strong>&lt;network name|ID&gt;</strong>: Join the network with the
given name or ID, e.g. use <code>--network mynet</code> to join the
network with the name mynet. Only supported for rootful users.</li>
</ul>
<h4 id="no-cache"><strong>--no-cache</strong></h4>
<p>Do not use existing cached images for the container build. Build from
the start with a new set of cached layers.</p>
<h4 id="no-hosts"><strong>--no-hosts</strong></h4>
<p>Do not create <em>/etc/hosts</em> for the container. By default,
Podman will manage <em>/etc/hosts</em>, adding the container's own IP
address and any hosts from <strong>--add-host</strong>.
<strong>--no-hosts</strong> disables this, and the image's
<em>/etc/hosts</em> will be preserved unmodified.</p>
<p>This option conflicts with <strong>--add-host</strong>.</p>
<h4 id="omit-history"><strong>--omit-history</strong></h4>
<p>Omit build history information in the built image. (default
false).</p>
<p>This option is useful for the cases where end users explicitly want
to set <code>--omit-history</code> to omit the optional
<code>History</code> from built images or when working with images built
using build tools that do not include <code>History</code> information
in their images.</p>
<h4 id="osstring"><strong>--os</strong>=<em>string</em></h4>
<p>Set the OS of the image to be built, and that of the base image to be
pulled, if the build uses one, instead of using the current operating
system of the build host.</p>
<h4
id="os-featurefeature"><strong>--os-feature</strong>=<em>feature</em></h4>
<p>Set the name of a required operating system <em>feature</em> for the
image which will be built. By default, if the image is not based on
<em>scratch</em>, the base image's required OS feature list is kept, if
the base image specified any. This option is typically only meaningful
when the image's OS is Windows.</p>
<p>If <em>feature</em> has a trailing <code>-</code>, then the
<em>feature</em> is removed from the set of required features which will
be listed in the image.</p>
<h4
id="os-versionversion"><strong>--os-version</strong>=<em>version</em></h4>
<p>Set the exact required operating system <em>version</em> for the
image which will be built. By default, if the image is not based on
<em>scratch</em>, the base image's required OS version is kept, if the
base image specified one. This option is typically only meaningful when
the image's OS is Windows, and is typically set in Windows base images,
so using this option is usually unnecessary.</p>
<h4 id="output--ooutput-opts"><strong>--output</strong>,
<strong>-o</strong>=<em>output-opts</em></h4>
<p>Output destination (format: type=local,dest=path)</p>
<p>The --output (or -o) option extends the default behavior of building
a container image by allowing users to export the contents of the image
as files on the local filesystem, which can be useful for generating
local binaries, code generation, etc. (This option is not available with
the remote Podman client, including Mac and Windows (excluding WSL2)
machines)</p>
<p>The value for --output is a comma-separated sequence of key=value
pairs, defining the output type and options.</p>
<p>Supported <em>keys</em> are: - <strong>dest</strong>: Destination
path for exported output. Valid value is absolute or relative path,
<code>-</code> means the standard output. - <strong>type</strong>:
Defines the type of output to be used. Valid values is documented
below.</p>
<p>Valid <em>type</em> values are: - <strong>local</strong>: write the
resulting build files to a directory on the client-side. -
<strong>tar</strong>: write the resulting files as a single tarball
(.tar).</p>
<p>If no type is specified, the value defaults to
<strong>local</strong>. Alternatively, instead of a comma-separated
sequence, the value of <strong>--output</strong> can be just a
destination (in the <code>**dest** format) (e.g.</code>--output
some-path<code>,</code>--output -<code>) where</code>--output
some-path<code>is treated as if **type=local** and</code>--output -` is
treated as if <strong>type=tar</strong>.</p>
<h4 id="pidpid"><strong>--pid</strong>=<em>pid</em></h4>
<p>Sets the configuration for PID namespaces when handling
<code>RUN</code> instructions. The configured value can be "" (the empty
string) or "container" to indicate that a new PID namespace should be
created, or it can be "host" to indicate that the PID namespace in which
<code>podman</code> itself is being run should be reused, or it can be
the path to a PID namespace which is already in use by another
process.</p>
<h4
id="platformosarchvariant..."><strong>--platform</strong>=<em>os/arch[/variant][,...]</em></h4>
<p>Set the <em>os/arch</em> of the built image (and its base image, if
your build uses one) to the provided value instead of using the current
operating system and architecture of the host (for example
<code>linux/arm</code>). If <code>--platform</code> is set, then the
values of the <code>--arch</code>, <code>--os</code>, and
<code>--variant</code> options will be overridden.</p>
<p>The <code>--platform</code> option can be specified more than once,
or given a comma-separated list of values as its argument. When more
than one platform is specified, the <code>--manifest</code> option
should be used instead of the <code>--tag</code> option.</p>
<p>Os/arch pairs are those used by the Go Programming Language. In
several cases the <em>arch</em> value for a platform differs from one
produced by other tools such as the <code>arch</code> command. Valid OS
and architecture name combinations are listed as values for $GOOS and
$GOARCH at https://golang.org/doc/install/source#environment, and can
also be found by running <code>go tool dist list</code>.</p>
<p>While <code>podman build</code> is happy to use base images and build
images for any platform that exists, <code>RUN</code> instructions will
not be able to succeed without the help of emulation provided by
packages like <code>qemu-user-static</code>.</p>
<h4 id="pullpolicy"><strong>--pull</strong>=<em>policy</em></h4>
<p>Pull image policy. The default is <strong>always</strong>.</p>
<ul>
<li><strong>always</strong>, <strong>true</strong>: Always pull the
image and throw an error if the pull fails.</li>
<li><strong>missing</strong>: Pull the image only if it could not be
found in the local containers storage. Throw an error if no image could
be found and the pull fails.</li>
<li><strong>never</strong>, <strong>false</strong>: Never pull the image
but use the one from the local containers storage. Throw an error if no
image could be found.</li>
<li><strong>newer</strong>: Pull if the image on the registry is newer
than the one in the local containers storage. An image is considered to
be newer when the digests are different. Comparing the time stamps is
prone to errors. Pull errors are suppressed if a local image was
found.</li>
</ul>
<h4 id="quiet--q"><strong>--quiet</strong>, <strong>-q</strong></h4>
<p>Suppress output messages which indicate which instruction is being
processed, and of progress when pulling images from a registry, and when
writing the output image.</p>
<h4 id="rm"><strong>--rm</strong></h4>
<p>Remove intermediate containers after a successful build (default
true).</p>
<h4 id="runtimepath"><strong>--runtime</strong>=<em>path</em></h4>
<p>The <em>path</em> to an alternate OCI-compatible runtime, which will
be used to run commands specified by the <strong>RUN</strong>
instruction.</p>
<p>Note: You can also override the default runtime by setting the
BUILDAH_RUNTIME environment variable.
<code>export BUILDAH_RUNTIME=/usr/local/bin/runc</code></p>
<h4
id="secretididsrcpath"><strong>--secret</strong>=<strong>id=id,src=path</strong></h4>
<p>Pass secret information to be used in the Containerfile for building
images in a safe way that will not end up stored in the final image, or
be seen in other stages. The secret will be mounted in the container at
the default location of <code>/run/secrets/id</code>.</p>
<p>To later use the secret, use the --mount option in a <code>RUN</code>
instruction within a <code>Containerfile</code>:</p>
<p><code>RUN --mount=type=secret,id=mysecret cat /run/secrets/mysecret</code></p>
<h4
id="security-optoption"><strong>--security-opt</strong>=<em>option</em></h4>
<p>Security Options</p>
<ul>
<li><p><code>apparmor=unconfined</code> : Turn off apparmor confinement
for the container</p></li>
<li><p><code>apparmor=your-profile</code> : Set the apparmor confinement
profile for the container</p></li>
<li><p><code>label=user:USER</code> : Set the label user for the
container processes</p></li>
<li><p><code>label=role:ROLE</code> : Set the label role for the
container processes</p></li>
<li><p><code>label=type:TYPE</code> : Set the label process type for the
container processes</p></li>
<li><p><code>label=level:LEVEL</code> : Set the label level for the
container processes</p></li>
<li><p><code>label=filetype:TYPE</code> : Set the label file type for
the container files</p></li>
<li><p><code>label=disable</code> : Turn off label separation for the
container</p></li>
<li><p><code>no-new-privileges</code> : Not supported</p></li>
<li><p><code>seccomp=unconfined</code> : Turn off seccomp confinement
for the container</p></li>
<li><p><code>seccomp=profile.json</code> : White listed syscalls seccomp
Json file to be used as a seccomp filter</p></li>
</ul>
<h4 id="shm-sizesize"><strong>--shm-size</strong>=<em>size</em></h4>
<p>Size of <code>/dev/shm</code>. The format is
<code>&lt;number&gt;&lt;unit&gt;</code>. <code>number</code> must be
greater than <code>0</code>. Unit is optional and can be <code>b</code>
(bytes), <code>k</code> (kibibytes), <code>m</code>(mebibytes), or
<code>g</code> (gibibytes). If you omit the unit, the system uses bytes.
If you omit the size entirely, the system uses <code>64m</code>.</p>
<h4
id="sign-byfingerprint"><strong>--sign-by</strong>=<em>fingerprint</em></h4>
<p>Sign the image using a GPG key with the specified FINGERPRINT. (This
option is not available with the remote Podman client, including Mac and
Windows (excluding WSL2) machines,)</p>
<h4 id="squash"><strong>--squash</strong></h4>
<p>Squash all of the image's new layers into a single new layer; any
preexisting layers are not squashed.</p>
<h4 id="squash-all"><strong>--squash-all</strong></h4>
<p>Squash all of the new image's layers (including those inherited from
a base image) into a single new layer.</p>
<h4 id="sshdefault-idsocket"><strong>--ssh</strong>=<em>default</em> |
<em>id[=socket&gt;</em></h4>
<p>SSH agent socket or keys to expose to the build. The socket path can
be left empty to use the value of
<code>default=$SSH_AUTH_SOCK</code></p>
<p>To later use the ssh agent, use the --mount option in a
<code>RUN</code> instruction within a <code>Containerfile</code>:</p>
<p><code>RUN --mount=type=ssh,id=id mycmd</code></p>
<h4 id="stdin"><strong>--stdin</strong></h4>
<p>Pass stdin into the RUN containers. Sometime commands being RUN
within a Containerfile want to request information from the user. For
example apt asking for a confirmation for install. Use --stdin to be
able to interact from the terminal during the build.</p>
<h4 id="tag--timagename"><strong>--tag</strong>,
<strong>-t</strong>=<em>imageName</em></h4>
<p>Specifies the name which will be assigned to the resulting image if
the build process completes successfully. If <em>imageName</em> does not
include a registry name, the registry name <em>localhost</em> will be
prepended to the image name.</p>
<h4
id="targetstagename"><strong>--target</strong>=<em>stageName</em></h4>
<p>Set the target build stage to build. When building a Containerfile
with multiple build stages, --target can be used to specify an
intermediate build stage by name as the final stage for the resulting
image. Commands after the target stage will be skipped.</p>
<h4
id="timestampseconds"><strong>--timestamp</strong>=<em>seconds</em></h4>
<p>Set the create timestamp to seconds since epoch to allow for
deterministic builds (defaults to current time). By default, the created
timestamp is changed and written into the image manifest with every
commit, causing the image's sha256 hash to be different even if the
sources are exactly the same otherwise. When --timestamp is set, the
created timestamp is always set to the time specified and therefore not
changed, allowing the image's sha256 hash to remain the same. All files
committed to the layers of the image will be created with the
timestamp.</p>
<p>If the only instruction in a Containerfile is <code>FROM</code>, this
flag has no effect.</p>
<h4 id="tls-verify"><strong>--tls-verify</strong></h4>
<p>Require HTTPS and verify certificates when talking to container
registries (defaults to true). (This option is not available with the
remote Podman client, including Mac and Windows (excluding WSL2)
machines)</p>
<h4
id="ulimittypesoft-limithard-limit"><strong>--ulimit</strong>=<em>type=soft-limit[:hard-limit]</em></h4>
<p>Specifies resource limits to apply to processes launched when
processing <code>RUN</code> instructions. This option can be specified
multiple times. Recognized resource types include: "core": maximum core
dump size (ulimit -c) "cpu": maximum CPU time (ulimit -t) "data":
maximum size of a process's data segment (ulimit -d) "fsize": maximum
size of new files (ulimit -f) "locks": maximum number of file locks
(ulimit -x) "memlock": maximum amount of locked memory (ulimit -l)
"msgqueue": maximum amount of data in message queues (ulimit -q) "nice":
niceness adjustment (nice -n, ulimit -e) "nofile": maximum number of
open files (ulimit -n) "nproc": maximum number of processes (ulimit -u)
"rss": maximum size of a process's (ulimit -m) "rtprio": maximum
real-time scheduling priority (ulimit -r) "rttime": maximum amount of
real-time execution between blocking syscalls "sigpending": maximum
number of pending signals (ulimit -i) "stack": maximum stack size
(ulimit -s)</p>
<h4 id="unsetenvenv"><strong>--unsetenv</strong>=<em>env</em></h4>
<p>Unset environment variables from the final image.</p>
<h4 id="usernshow"><strong>--userns</strong>=<em>how</em></h4>
<p>Sets the configuration for user namespaces when handling
<code>RUN</code> instructions. The configured value can be "" (the empty
string) or "container" to indicate that a new user namespace should be
created, it can be "host" to indicate that the user namespace in which
<code>podman</code> itself is being run should be reused, or it can be
the path to a user namespace which is already in use by another
process.</p>
<h4
id="userns-gid-mapmapping"><strong>--userns-gid-map</strong>=<em>mapping</em></h4>
<p>Directly specifies a GID mapping which should be used to set
ownership, at the filesystem level, on the working container's contents.
Commands run when handling <code>RUN</code> instructions will default to
being run in their own user namespaces, configured using the UID and GID
maps.</p>
<p>Entries in this map take the form of one or more triples of a
starting in-container GID, a corresponding starting host-level GID, and
the number of consecutive IDs which the map entry represents.</p>
<p>This option overrides the <em>remap-gids</em> setting in the
<em>options</em> section of /etc/containers/storage.conf.</p>
<p>If this option is not specified, but a global --userns-gid-map
setting is supplied, settings from the global option will be used.</p>
<p>If none of --userns-uid-map-user, --userns-gid-map-group, or
--userns-gid-map are specified, but --userns-uid-map is specified, the
GID map will be set to use the same numeric values as the UID map.</p>
<h4
id="userns-gid-map-groupgroup"><strong>--userns-gid-map-group</strong>=<em>group</em></h4>
<p>Specifies that a GID mapping which should be used to set ownership,
at the filesystem level, on the working container's contents, can be
found in entries in the <code>/etc/subgid</code> file which correspond
to the specified group. Commands run when handling <code>RUN</code>
instructions will default to being run in their own user namespaces,
configured using the UID and GID maps. If --userns-uid-map-user is
specified, but --userns-gid-map-group is not specified,
<code>podman</code> will assume that the specified user name is also a
suitable group name to use as the default setting for this option.</p>
<p><strong>NOTE:</strong> When this option is specified by a rootless
user, the specified mappings are relative to the rootless user namespace
in the container, rather than being relative to the host as it would be
when run rootful.</p>
<h4
id="userns-uid-mapmapping"><strong>--userns-uid-map</strong>=<em>mapping</em></h4>
<p>Directly specifies a UID mapping which should be used to set
ownership, at the filesystem level, on the working container's contents.
Commands run when handling <code>RUN</code> instructions will default to
being run in their own user namespaces, configured using the UID and GID
maps.</p>
<p>Entries in this map take the form of one or more triples of a
starting in-container UID, a corresponding starting host-level UID, and
the number of consecutive IDs which the map entry represents.</p>
<p>This option overrides the <em>remap-uids</em> setting in the
<em>options</em> section of /etc/containers/storage.conf.</p>
<p>If this option is not specified, but a global --userns-uid-map
setting is supplied, settings from the global option will be used.</p>
<p>If none of --userns-uid-map-user, --userns-gid-map-group, or
--userns-uid-map are specified, but --userns-gid-map is specified, the
UID map will be set to use the same numeric values as the GID map.</p>
<h4
id="userns-uid-map-useruser"><strong>--userns-uid-map-user</strong>=<em>user</em></h4>
<p>Specifies that a UID mapping which should be used to set ownership,
at the filesystem level, on the working container's contents, can be
found in entries in the <code>/etc/subuid</code> file which correspond
to the specified user. Commands run when handling <code>RUN</code>
instructions will default to being run in their own user namespaces,
configured using the UID and GID maps. If --userns-gid-map-group is
specified, but --userns-uid-map-user is not specified,
<code>podman</code> will assume that the specified group name is also a
suitable user name to use as the default setting for this option.</p>
<p><strong>NOTE:</strong> When this option is specified by a rootless
user, the specified mappings are relative to the rootless user namespace
in the container, rather than being relative to the host as it would be
when run rootful.</p>
<h4 id="utshow"><strong>--uts</strong>=<em>how</em></h4>
<p>Sets the configuration for UTS namespaces when handling
<code>RUN</code> instructions. The configured value can be "" (the empty
string) or "container" to indicate that a new UTS namespace should be
created, or it can be "host" to indicate that the UTS namespace in which
<code>podman</code> itself is being run should be reused, or it can be
the path to a UTS namespace which is already in use by another
process.</p>
<h4 id="variantvariant"><strong>--variant</strong>=<em>variant</em></h4>
<p>Set the architecture variant of the image to be built, and that of
the base image to be pulled, if the build uses one, to the provided
value instead of using the architecture variant of the build host.</p>
<h4
id="volume--vhost-dircontainer-diroptions"><strong>--volume</strong>,
<strong>-v</strong>=<em>[HOST-DIR:CONTAINER-DIR[:OPTIONS]]</em></h4>
<p>Create a bind mount. If you specify
<code>-v /HOST-DIR:/CONTAINER-DIR</code>, Podman bind mounts
<code>/HOST-DIR</code> in the host to <code>/CONTAINER-DIR</code> in the
Podman container. (This option is not available with the remote Podman
client, including Mac and Windows (excluding WSL2) machines)</p>
<p>The <code>OPTIONS</code> are a comma-separated list and can be:
<sup><a href="#Footnote1">[1]</a></sup></p>
<ul>
<li>[rw|ro]</li>
<li>[z|Z|O]</li>
<li>[U]</li>
<li>[<code>[r]shared</code>|<code>[r]slave</code>|<code>[r]private</code>]</li>
</ul>
<p>The <code>CONTAINER-DIR</code> must be an absolute path such as
<code>/src/docs</code>. The <code>HOST-DIR</code> must be an absolute
path as well. Podman bind-mounts the <code>HOST-DIR</code> to the path
you specify. For example, if you supply <code>/foo</code> as the host
path, Podman copies the contents of <code>/foo</code> to the container
filesystem on the host and bind mounts that into the container.</p>
<p>You can specify multiple <strong>-v</strong> options to mount one or
more mounts to a container.</p>
<p>You can add the <code>:ro</code> or <code>:rw</code> suffix to a
volume to mount it read-only or read-write mode, respectively. By
default, the volumes are mounted read-write. See examples.</p>
<p><code>Chowning Volume Mounts</code></p>
<p>By default, Podman does not change the owner and group of source
volume directories mounted. When running using user namespaces, the UID
and GID inside the namespace may correspond to another UID and GID on
the host.</p>
<p>The <code>:U</code> suffix tells Podman to use the correct host UID
and GID based on the UID and GID within the namespace, to change
recursively the owner and group of the source volume.</p>
<p><strong>Warning</strong> use with caution since this will modify the
host filesystem.</p>
<p><code>Labeling Volume Mounts</code></p>
<p>Labeling systems like SELinux require that proper labels are placed
on volume content mounted into a container. Without a label, the
security system might prevent the processes running inside the container
from using the content. By default, Podman does not change the labels
set by the OS.</p>
<p>To change a label in the container context, you can add either of two
suffixes <code>:z</code> or <code>:Z</code> to the volume mount. These
suffixes tell Podman to relabel file objects on the shared volumes. The
<code>z</code> option tells Podman that two containers share the volume
content. As a result, Podman labels the content with a shared content
label. Shared volume labels allow all containers to read/write content.
The <code>Z</code> option tells Podman to label the content with a
private unshared label. Only the current container can use a private
volume.</p>
<p>Note: Do not relabel system files and directories. Relabeling system
content might cause other confined services on your machine to fail. For
these types of containers, disabling SELinux separation is recommended.
The option <code>--security-opt label=disable</code> disables SELinux
separation for the container. For example, if a user wanted to volume
mount their entire home directory into the build containers, they need
to disable SELinux separation.</p>
<pre><code>   $ podman build --security-opt label=disable -v $HOME:/home/user .</code></pre>
<p><code>Overlay Volume Mounts</code></p>
<p>The <code>:O</code> flag tells Podman to mount the directory from the
host as a temporary storage using the Overlay file system. The
<code>RUN</code> command containers are allowed to modify contents
within the mountpoint and are stored in the container storage in a
separate directory. In Overlay FS terms the source directory will be the
lower, and the container storage directory will be the upper.
Modifications to the mount point are destroyed when the <code>RUN</code>
command finishes executing, similar to a tmpfs mount point.</p>
<p>Any subsequent execution of <code>RUN</code> commands sees the
original source directory content, any changes from previous RUN
commands no longer exists.</p>
<p>One use case of the <code>overlay</code> mount is sharing the package
cache from the host into the container to allow speeding up builds.</p>
<p>Note:</p>
<pre><code> - Overlay mounts are not currently supported in rootless mode.
 - The `O` flag is not allowed to be specified with the `Z` or `z` flags.</code></pre>
<p>Content mounted into the container is labeled with the private label.
On SELinux systems, labels in the source directory needs to be readable
by the container label. If not, SELinux container separation must be
disabled for the container to work. - Modification of the directory
volume mounted into the container with an overlay mount can cause
unexpected failures. It is recommended that you do not modify the
directory until the container finishes running.</p>
<p>By default bind mounted volumes are <code>private</code>. That means
any mounts done inside containers will not be visible on the host and
vice versa. This behavior can be changed by specifying a volume mount
propagation property.</p>
<p>When the mount propagation policy is set to <code>shared</code>, any
mounts completed inside the container on that volume will be visible to
both the host and container. When the mount propagation policy is set to
<code>slave</code>, one way mount propagation is enabled and any mounts
completed on the host for that volume will be visible only inside of the
container. To control the mount propagation property of volume use the
<code>:[r]shared</code>, <code>:[r]slave</code> or
<code>:[r]private</code> propagation flag. For mount propagation to work
on the source mount point (mount point where source dir is mounted on)
has to have the right propagation properties. For shared volumes, the
source mount point has to be shared. And for slave volumes, the source
mount has to be either shared or slave. <sup><a
href="#Footnote1">[1]</a></sup></p>
<p>Use <code>df &lt;source-dir&gt;</code> to determine the source mount
and then use
<code>findmnt -o TARGET,PROPAGATION &lt;source-mount-dir&gt;</code> to
determine propagation properties of source mount, if
<code>findmnt</code> utility is not available, the source mount point
can be determined by looking at the mount entry in
<code>/proc/self/mountinfo</code>. Look at <code>optional fields</code>
and see if any propagation properties are specified.
<code>shared:X</code> means the mount is <code>shared</code>,
<code>master:X</code> means the mount is <code>slave</code> and if
nothing is there that means the mount is <code>private</code>. <sup><a
href="#Footnote1">[1]</a></sup></p>
<p>To change propagation properties of a mount point use the
<code>mount</code> command. For example, to bind mount the source
directory <code>/foo</code> do <code>mount --bind /foo /foo</code> and
<code>mount --make-private --make-shared /foo</code>. This will convert
/foo into a <code>shared</code> mount point. The propagation properties
of the source mount can be changed directly. For instance if
<code>/</code> is the source mount for <code>/foo</code>, then use
<code>mount --make-shared /</code> to convert <code>/</code> into a
<code>shared</code> mount.</p>
<h2 id="examples">EXAMPLES</h2>
<h3 id="build-an-image-using-local-containerfiles">Build an image using
local Containerfiles</h3>
<pre><code>$ podman build .

$ podman build -f Containerfile.simple .

$ cat $HOME/Containerfile | podman build -f - .

$ podman build -f Containerfile.simple -f Containerfile.notsosimple .

$ podman build -f Containerfile.in $HOME

$ podman build -t imageName .

$ podman build --tls-verify=true -t imageName -f Containerfile.simple .

$ podman build --tls-verify=false -t imageName .

$ podman build --runtime-flag log-format=json .

$ podman build --runtime-flag debug .

$ podman build --authfile /tmp/auths/myauths.json --cert-dir $HOME/auth --tls-verify=true --creds=username:password -t imageName -f Containerfile.simple .

$ podman build --memory 40m --cpu-period 10000 --cpu-quota 50000 --ulimit nofile=1024:1028 -t imageName .

$ podman build --security-opt label=level:s0:c100,c200 --cgroup-parent /path/to/cgroup/parent -t imageName .

$ podman build --volume /home/test:/myvol:ro,Z -t imageName .

$ podman build -v /var/lib/yum:/var/lib/yum:O -t imageName .

$ podman build --layers -t imageName .

$ podman build --no-cache -t imageName .

$ podman build --layers --force-rm -t imageName .

$ podman build --no-cache --rm=false -t imageName .

$ podman build --network mynet .</code></pre>
<h3
id="building-a-multi-architecture-image-using-the---manifest-option-requires-emulation-software">Building
a multi-architecture image using the --manifest option (requires
emulation software)</h3>
<pre><code>$ podman build --arch arm --manifest myimage /tmp/mysrc

$ podman build --arch amd64 --manifest myimage /tmp/mysrc

$ podman build --arch s390x --manifest myimage /tmp/mysrc

$ podman build --platform linux/s390x,linux/ppc64le,linux/amd64 --manifest myimage /tmp/mysrc

$ podman build --platform linux/arm64 --platform linux/amd64 --manifest myimage /tmp/mysrc</code></pre>
<h3 id="building-an-image-using-a-url-git-repo-or-archive">Building an
image using a URL, Git repo, or archive</h3>
<p>The build context directory can be specified as a URL to a
Containerfile, a Git repository, or URL to an archive. If the URL is a
Containerfile, it is downloaded to a temporary location and used as the
context. When a Git repository is set as the URL, the repository is
cloned locally to a temporary location and then used as the context.
Lastly, if the URL is an archive, it is downloaded to a temporary
location and extracted before being used as the context.</p>
<h4 id="building-an-image-using-a-url-to-a-containerfile">Building an
image using a URL to a Containerfile</h4>
<p>Podman will download the Containerfile to a temporary location and
then use it as the build context.</p>
<pre><code>$ podman build https://10.10.10.1/podman/Containerfile</code></pre>
<h4 id="building-an-image-using-a-git-repository">Building an image
using a Git repository</h4>
<p>Podman will clone the specified GitHub repository to a temporary
location and use it as the context. The Containerfile at the root of the
repository will be used and it only works if the GitHub repository is a
dedicated repository.</p>
<pre><code>$ podman build https://github.com/scollier/purpletest</code></pre>
<p>Note: Github does not support using <code>git://</code> for
performing <code>clone</code> operation due to recent changes in their
security guidance
(https://github.blog/2021-09-01-improving-git-protocol-security-github/).
Use an <code>https://</code> URL if the source repository is hosted on
Github.</p>
<h4 id="building-an-image-using-a-url-to-an-archive">Building an image
using a URL to an archive</h4>
<p>Podman will fetch the archive file, decompress it, and use its
contents as the build context. The Containerfile at the root of the
archive and the rest of the archive will get used as the context of the
build. If you pass <code>-f PATH/Containerfile</code> option as well,
the system will look for that file inside the contents of the
archive.</p>
<pre><code>$ podman build -f dev/Containerfile https://10.10.10.1/podman/context.tar.gz</code></pre>
<p>Note: supported compression formats are 'xz', 'bzip2', 'gzip' and
'identity' (no compression).</p>
<h2 id="files">Files</h2>
<h3
id="containerignore.dockerignore">.containerignore/.dockerignore</h3>
<p>If the file <em>.containerignore</em> or <em>.dockerignore</em>
exists in the context directory, <code>podman build</code> reads its
contents. Use the <code>--ignorefile</code> option to override the
.containerignore path location. Podman uses the content to exclude files
and directories from the context directory, when executing COPY and ADD
directives in the Containerfile/Dockerfile</p>
<p>The .containerignore and .dockerignore files use the same syntax; if
both are in the context directory, podman build will only use
.containerignore.</p>
<p>Users can specify a series of Unix shell globs in a .containerignore
file to identify files/directories to exclude.</p>
<p>Podman supports a special wildcard string <code>**</code> which
matches any number of directories (including zero). For example, **/*.go
will exclude all files that end with .go that are found in all
directories.</p>
<p>Example .containerignore file:</p>
<pre><code># exclude this content for image
*/*.c
**/output*
src</code></pre>
<p><code>*/*.c</code> Excludes files and directories whose names ends
with .c in any top level subdirectory. For example, the source file
include/rootless.c.</p>
<p><code>**/output*</code> Excludes files and directories starting with
<code>output</code> from any directory.</p>
<p><code>src</code> Excludes files named src and the directory src as
well as any content in it.</p>
<p>Lines starting with ! (exclamation mark) can be used to make
exceptions to exclusions. The following is an example .containerignore
file that uses this mechanism:</p>
<pre><code>*.doc
!Help.doc</code></pre>
<p>Exclude all doc files except Help.doc from the image.</p>
<p>This functionality is compatible with the handling of
.containerignore files described here:</p>
<p>https://github.com/containers/common/blob/main/docs/containerignore.5.md</p>
<p><strong>registries.conf</strong>
(<code>/etc/containers/registries.conf</code>)</p>
<p>registries.conf is the configuration file which specifies which
container registries should be consulted when completing image names
which do not include a registry or domain portion.</p>
<h2 id="troubleshooting">Troubleshooting</h2>
<h3 id="lastlog-sparse-file">lastlog sparse file</h3>
<p>If you are using a useradd command within a Containerfile with a
large UID/GID, it will create a large sparse file
<code>/var/log/lastlog</code>. This can cause the build to hang forever.
Go language does not support sparse files correctly, which can lead to
some huge files being created in your container image.</p>
<p>If you are using <code>useradd</code> within your build script, you
should pass the <code>--no-log-init or -l</code> option to the
<code>useradd</code> command. This option tells useradd to stop creating
the lastlog file.</p>
<h2 id="see-also">SEE ALSO</h2>
<p><strong><a href="podman.html">podman(1)</a></strong>, <strong><a
href="https://github.com/containers/buildah/blob/main/docs/buildah.html">buildah(1)</a></strong>,
<strong><a
href="https://github.com/containers/image/blob/main/docs/containers-certs.d.5.md">containers-certs.d(5)</a></strong>,
<strong><a
href="https://github.com/containers/image/blob/main/docs/containers-registries.conf.5.md">containers-registries.conf(5)</a></strong>,
<strong><a
href="https://github.com/containers/crun/blob/main/crun.html">crun(1)</a></strong>,
<strong><a
href="https://github.com/opencontainers/runc/blob/master/man/runc.8.md">runc(8)</a></strong>,
<strong><a
href="https://www.unix.com/man-page/redhat/8/useradd">useradd(8)</a></strong>,
<strong><a href="podman-ps.html">podman-ps(1)</a></strong>, <strong><a
href="podman-rm.html">podman-rm(1)</a></strong>, <strong><a
href="https://github.com/containers/common/blob/main/docs/Containerfile.5.md">Containerfile(5)</a></strong>,
<strong><a
href="https://github.com/containers/common/blob/main/docs/containerignore.5.md">containerignore(5)</a></strong></p>
<h2 id="history">HISTORY</h2>
<p>Aug 2020, Additional options and .containerignore added by Dan Walsh
<code>&lt;dwalsh@redhat.com&gt;</code></p>
<p>May 2018, Minor revisions added by Joe Doss
<code>&lt;joe@solidadmin.com&gt;</code></p>
<p>December 2017, Originally compiled by Tom Sweeney
<code>&lt;tsweeney@redhat.com&gt;</code></p>
<h2 id="footnotes">FOOTNOTES</h2>
<p><a name="Footnote1">1</a>: The Podman project is committed to
inclusivity, a core value of open source. The <code>master</code> and
<code>slave</code> mount propagation terminology used here is
problematic and divisive, and should be changed. However, these terms
are currently used within the Linux kernel and must be used as-is at
this time. When the kernel maintainers rectify this usage, Podman will
follow suit immediately.</p>
</body>
</html>
